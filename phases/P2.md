# Phase 2: Basic Validation

## Overview

Phase 2 implements core validation functionality for Splunk TA configuration files. This phase builds upon the CLI framework established in Phase 1.

## Core Requirements

### Validation Framework

1. Core Validation Rules (in order of implementation)
   - Line-level validation:
     - Key-value pair format
     - Comment format
     - Stanza header format
   - Stanza-level validation:
     - Duplicate key detection
     - Required keys (if any)
   - Content-level validation:
     - Duplicate stanza detection
     - Overall structure
   - File-level validation:
     - UTF-8 encoding check
     - File extension check (.conf and .meta)
     - Basic file access/permissions

2. Command Structure

   ```python
   @cli.command()
   @click.option("--verbose", is_flag=True, help="Show detailed output")
   @click.option("--dry-run", is_flag=True, help="Show what would be done without making changes")
   @click.option("--report", is_flag=True, help="Generate validation report")
   @click.argument("files", nargs=-1)
   def validate(verbose: bool, dry_run: bool, report: bool, files: tuple[str, ...]) -> None:
       """Verify configuration structure and syntax."""
       click.echo("Validate command not yet implemented")
   ```

3. Output Formatting
   - Error messages include:
     - File path
     - Line number
     - Error description
     - Context (surrounding lines)
   - Success messages show:
     - Summary of checks passed
     - File statistics
     - Warning count

   Note: Initial implementation will use the Minimal Style output format:

   ```bash
   $ bydefault validate props.conf
   props.conf ✓ 48 stanzas, 156 lines
   transforms.conf ✓ 12 stanzas, 89 lines
   limits.conf ✗ 2 errors found
   ```

   Additional output styles are documented for future consideration.
   [Output style examples remain unchanged for discussion]

   1. Detailed Table Style:

      ```bash
      $ bydefault validate --report *.conf
      File              Status   Stanzas   Lines   Errors   Warnings
      ───────────────────────────────────────────────────────────────
      props.conf        PASS     48        156     0        0
      transforms.conf   PASS     12        89      0        0
      limits.conf      *FAIL     15        67      2        1
      
      Total Files: 3   Pass: 2   Fail: 1   Stanzas: 75   Lines: 312
      ```

   2. Error Context Style (current):

      ```bash
      $ bydefault validate limits.conf
      Validating limits.conf...

      Error in limits.conf:123
      │ Invalid stanza format
      │ 
      │   121 │ [source::access_combined]
      │   122 │ SHOULD_LINEMERGE = false
      │ > 123 │ [malformed:stanza
      │   124 │ SHOULD_LINEMERGE = true
      │   125 │ 
      ```

   3. Progress Style:

      ```bash
      $ bydefault validate --verbose *.conf
      Validating configuration files...
      props.conf      [==================] 156 lines ✓
      transforms.conf [==================]  89 lines ✓
      limits.conf     [==================]  67 lines ✗

      Found 2 errors in limits.conf:
      • Line 123: Invalid stanza format
      • Line 145: Duplicate key in stanza [source::access_combined]
      ```

   4. Coverage Style:

      ```bash
      $ bydefault validate --strict props.conf
      props.conf validation results:
      > Lines:     156/156 valid
      > Stanzas:   48/48   valid
      > Keys:      234/234 valid
      > Encoding:  UTF-8    ✓
      > Structure: Valid    ✓
      
      All validation checks passed!
      ```

### Implementation Details

1. Project Structure

   ```bash
   src/bydefault/
       commands/
           __init__.py
           validator.py
       models/
           __init__.py
           splunk_config.py
           validation_results.py
   ```

2. Model Implementation
   - Models use dataclasses for clean, maintainable code
   - Type hints show relationships between models
   - Models build from smallest scope (line) to largest (file)
   - Internal models not exposed in public API

   Example Model Structure:

   ```python
   from dataclasses import dataclass
   from pathlib import Path
   from typing import Sequence, Mapping

   @dataclass
   class ConfigLine:
       """Represents a single line in a configuration file"""
       number: int
       content: str

   @dataclass
   class ConfigStanza:
       """Represents a parsed stanza with its content"""
       name: str
       start_line: int
       lines: Sequence[ConfigLine]  # Relationship to ConfigLine
       key_values: Mapping[str, str]

   @dataclass
   class ParsedConfig:
       """Represents a fully parsed configuration file"""
       file_path: Path
       stanzas: Sequence[ConfigStanza]  # Relationship to ConfigStanza

   @dataclass
   class ValidationIssue:
       """Single validation issue"""
       line_number: int
       message: str
       context: str

   @dataclass
   class ValidationResult:
       """Validation results for a configuration file"""
       file_path: Path
       is_valid: bool
       issues: Sequence[ValidationIssue]  # Relationship to ValidationIssue
   ```

3. Command Implementation
   - Support both programmatic and CLI usage
   - Process files individually for validation
   - Support directory-level validation for TAs
   - Prompt for confirmation on root directory validation

## Success Criteria

1. Validation Framework
   - [ ] Line-level validation complete
   - [ ] Stanza-level validation complete
   - [ ] Content-level validation complete
   - [ ] File-level validation complete

2. Output System
   - [ ] Error messages show line numbers and context
   - [ ] Summary reports show relevant statistics
   - [ ] Minimal style output implemented

3. Testing Coverage
   - [ ] All validation rules tested
   - [ ] Edge cases covered
   - [ ] Error reporting verified
   - [ ] Command options tested

## Limitations

1. Validation Scope
   - Basic syntax validation only
   - No semantic validation
   - No cross-file validation
   - No custom rule support

2. Error Handling
   - Basic error reporting
   - No error correction
   - No validation suggestions

## Next Phase Dependencies

Phase 3 (File Detection) will build upon:

1. Validation rules for file structure
2. Error reporting system
3. File type detection

## Notes

- Implementation follows smallest to largest scope
- Focus on core validation functionality
- Establish patterns for rule implementation
- Prepare for integration with file operations
